generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id               String                  @id @default(uuid()) @db.Uuid
  email                 String                  @unique
  name                  String
  phone                 String?
  profileImage          String?
  address               String?
  role                  String
  createdAt             DateTime                @default(now())
  latitude              Float?
  longitude             Float?
  pets                  Pet[]
  notifications         Notification[]          @relation("UserNotifications")
  businessReservations  Reservation[]           @relation("BusinessReservations")
  reservations          Reservation[]           @relation("UserReservations")
  services              Service[]               @relation("UserServices")
  businessSchedules     BusinessSchedule[]      @relation("BusinessSchedules")
  businessServices      BusinessService[]       @relation("BusinessToServices")
  payments              Payment[]               @relation("UserPayments")
  businessPayments      Payment[]               @relation("BusinessPayments")
}

model Pet {
  pet_id       String        @id @default(uuid()) @db.Uuid
  user_id      String        @db.Uuid
  name         String
  species      String
  breed        String?
  age          Int?
  weight       Float?
  photo        String?
  created_at   DateTime      @default(now())
  updated_at   DateTime      @updatedAt
  user         User          @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  reservations Reservation[]
}

model Service {
  service_id            String                  @id @default(uuid()) @db.Uuid
  name                  String
  description           String
  price                 Decimal
  category              ServiceCategory
  created_at            DateTime                @default(now())
  updated_at            DateTime                @updatedAt
  admin_id              String                  @db.Uuid
  reservations          Reservation[]
  admin                 User                    @relation("UserServices", fields: [admin_id], references: [user_id])
  businessServices      BusinessService[]       @relation("ServiceToBusinesses")
  payments              Payment[]

  @@map("services")
}

model Reservation {
  reservation_id String            @id @default(uuid()) @db.Uuid
  user_id       String            @db.Uuid
  service_id    String?           @db.Uuid
  business_id   String            @db.Uuid
  pet_id        String?           @db.Uuid
  status        ReservationStatus
  notes         String?
  created_at    DateTime          @default(now())
  updated_at    DateTime          @updatedAt
  price         Decimal           @default(0)
  start_time    DateTime
  end_time      DateTime?         // 선택적 필드로 변경
  is_available  Boolean           @default(true)  // 예약 가능 여부
  business      User              @relation("BusinessReservations", fields: [business_id], references: [user_id], onDelete: Cascade)
  pet           Pet?              @relation(fields: [pet_id], references: [pet_id], onDelete: Cascade)
  service       Service?          @relation(fields: [service_id], references: [service_id], onDelete: Cascade)
  user          User              @relation("UserReservations", fields: [user_id], references: [user_id], onDelete: Cascade)
  payments      Payment[]

  @@index([business_id, start_time, end_time, is_available])
  @@index([user_id, start_time])
  @@map("reservations")
}

model Notification {
  notification_id String           @id @default(uuid()) @db.Uuid
  user_id         String           @db.Uuid
  message         String
  is_read         Boolean          @default(false)
  created_at      DateTime         @default(now())
  metadata        Json?
  title           String
  updated_at      DateTime         @updatedAt
  type            NotificationType
  user            User             @relation("UserNotifications", fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([user_id, is_read])
  @@index([created_at])
  @@map("notifications")
}

enum ServiceCategory {
  cremation
  bathing
  funeral
  grooming
  custom_vehicles
  other_care
}

enum ReservationStatus {
  PENDING
  CONFIRMED
  CANCELED
  COMPLETED
  IN_PROGRESS
  REJECTED
  NO_SHOW
  BLOCKED
}

enum NotificationType {
  RESERVATION_CREATED
  RESERVATION_UPDATED
  RESERVATION_CANCELED
  RESERVATION_ACCEPTED
  RESERVATION_REJECTED
  RESERVATION_COMPLETED
  RESERVATION_REMINDER
  REVIEW_REQUESTED
  REVIEW_RECEIVED
  PAYMENT_COMPLETED
  PAYMENT_FAILED
  SYSTEM
}

enum PaymentStatus {
  READY        // 결제 준비
  IN_PROGRESS  // 결제 진행중
  WAITING_FOR_DEPOSIT // 가상계좌 입금 대기
  PENDING      // 결제 대기
  DONE         // 결제 완료
  CANCELED     // 결제 취소
  ABORTED      // 결제 중단
  FAILED       // 결제 실패
}

enum PaymentMethod {
  CARD         // 카드 결제
  VIRTUAL_ACCOUNT // 가상계좌
  ACCOUNT_TRANSFER // 계좌이체
  MOBILE_PAYMENT   // 휴대폰 결제
  GIFT_CARD       // 상품권
  EASY_PAY        // 간편결제
}

model Payment {
  payment_id      String        @id @default(uuid()) @db.Uuid
  service_id      String        @db.Uuid
  business_id     String        @db.Uuid
  user_id         String        @db.Uuid
  reservation_id  String?       @db.Uuid
  orderId        String        // 주문 번호 (가맹점에서 생성한 주문 번호)
  paymentKey     String?       // 토스 페이먼츠 결제 키
  status         PaymentStatus
  method         PaymentMethod
  amount         Decimal
  approved_at    DateTime?     // 결제 승인 시각
  requested_at   DateTime      @default(now()) // 결제 요청 시각
  canceled_at    DateTime?     // 결제 취소 시각
  failed_at      DateTime?     // 결제 실패 시각
  cancel_reason  String?       // 결제 취소 사유
  fail_reason    String?       // 결제 실패 사유
  
  // 카드 결제 정보
  card_number    String?       // 마스킹된 카드 번호
  card_issuer    String?       // 카드 발급사
  card_acquirer  String?       // 카드 매입사
  card_installment_plan_months Int?  // 할부 개월 수
  
  // 가상계좌 정보
  virtual_account_number      String?  // 가상계좌 번호
  virtual_account_bank_code   String?  // 가상계좌 은행 코드
  virtual_account_due_date    DateTime? // 입금 기한
  
  // 영수증 정보
  receipt_url    String?      // 영수증 URL
  
  // 결제 요청 정보
  success_url   String?       // 성공 URL
  fail_url      String?       // 실패 URL
  memo          String?       // 메모
  
  // 메타데이터
  metadata       Json?         // 가맹점에서 전달한 추가 정보
  
  // 관계
  service        Service       @relation(fields: [service_id], references: [service_id], onDelete: Cascade)
  business       User          @relation("BusinessPayments", fields: [business_id], references: [user_id], onDelete: Cascade)
  user           User          @relation("UserPayments", fields: [user_id], references: [user_id], onDelete: Cascade)
  reservation    Reservation?  @relation(fields: [reservation_id], references: [reservation_id], onDelete: Cascade)

  @@index([orderId])
  @@index([paymentKey])
  @@index([status])
  @@index([requested_at])
  @@map("payments")
}

enum ScheduleType {
  WEEKLY  // 주간 스케줄
  BREAK   // 휴식 시간
}

model BusinessSchedule {
  id           String       @id @default(uuid()) @db.Uuid
  business_id  String       @db.Uuid
  schedule_data Json?        // 요일별 스케줄 데이터 (JSON 형식)
  day_of_week  String?      // 기존 방식 호환성 유지 (새 방식에서는 사용 안함)
  type         ScheduleType? // 기존 방식 호환성 유지 (새 방식에서는 사용 안함)
  start_time   String?      // 기존 방식 호환성 유지 (새 방식에서는 사용 안함)
  end_time     String?      // 기존 방식 호환성 유지 (새 방식에서는 사용 안함)
  reason       String?      // 기존 방식 호환성 유지 (새 방식에서는 사용 안함)
  is_day_off   Boolean?     @default(false) // 기존 방식 호환성 유지 (새 방식에서는 사용 안함)
  created_at   DateTime     @default(now())
  updated_at   DateTime     @updatedAt
  business     User         @relation("BusinessSchedules", fields: [business_id], references: [user_id], onDelete: Cascade)

  @@index([business_id])
  @@map("business_schedules")
}

model BusinessService {
  id           String   @id @default(uuid()) @db.Uuid
  business_id  String   @db.Uuid
  service_id   String   @db.Uuid
  is_active    Boolean  @default(true)

  business     User     @relation("BusinessToServices", fields: [business_id], references: [user_id], onDelete: Cascade)
  service      Service  @relation("ServiceToBusinesses", fields: [service_id], references: [service_id], onDelete: Cascade)
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  @@index([business_id])
  @@index([service_id])
  @@unique([business_id, service_id])
  @@map("business_services")
}
